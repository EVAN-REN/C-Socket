函数模板注意事项：
1）可以为类的成员函数创建模板，但不能是虚函数和析构函数
2）使用函数模版时，必须明确数据类型，确保实参与函数模版能匹配上
3）使用函数模版时，推倒的数据类型必须适应函数模版中的代码（模版函数内的运算必须是可以运行的运算）
4）使用函数模板时，如果是自动类型推到，不会发生隐式类型转换，如果显式指定了函数模板的数据类型，可以发生隐式类型转换
5）函数模版支持多个通用数据类型的参数
6）函数模板支持重载，可以有非通用数据类型的参数

函数模版的具体化
7）可以提供一个具体化的函数定义，当编译器找到与函数调用匹配的具体化定义时，将使用该定义不再寻找模板
template<> void 函数模板名(参数列表){}

8）编译器对各种函数的规则：
具体化函数优于常规模板，普通函数优于具体化和常规模版
如果希望使用函数模版，可以用空模版参数强制使用函数模版
如果函数模板能产生更好的匹配，将优先于非模板函数

9）函数模板只是函数的描述，没有实体，一般放在头文件中
但函数模板的具体化有实体，所以声明在头文件中，定义在源文件中

(c++11)decltype操作符，用于查询表达式的数据类型，但只能分析表达式得到类型，不能计算执行表达式
语法：decltype(expression) var;
10）如果expression是没有用括号括起来的标识符，则var的类型与该标识符的类型相同，包括const等限定字
11）如果expression是函数调用，则var的类型与函数的返回值类型相同（函数不能反回void，但可以返回void*）
12）如果expression是左值（能取地址）、或者用括号括起来的标识符，那么var的类型是expression的引用
13）如果上面的条件都不满足，则var的类型与expression的类型相同


类模版：
函数模板建议用typename描述通用数据类型，类模版建议用class
1）在创建对象时，必须指明具体的数据类型
2）使用模板时，数据类型必须适应类模版中的代码
3）类模版可以为通用参数指定缺省的数据类型
4）类的成员函数可以在类外实现
5）可以用new创建模版对象
6）在程序中，模版类的成员函数使用了才会创建

7）嵌套使用模版类
8）递归使用模版类